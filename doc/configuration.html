<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Marathon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Cross-platform test runner written for Android and iOS projects">
    <meta name="keywords" content="android, testing, testing-tool, test-runner, espresso, uitest, uitesting, uitests, ios, marathon, xcrun, instrumentation, instrumentation-tests, gradle, parallel, performance">

    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" rel="stylesheet"
          type="text/css">
    <!-- Animated -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="shortcut icon" href="/marathon/img/favicon.png">
    <!-- highlight  css -->
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/solarized-dark.min.css">
    <!-- main css -->
    <link rel="stylesheet" type="text/css" href="/marathon/css/marathon.css">
    <!-- tabs -->
    <link rel="stylesheet" type="text/css" href="/marathon/css/tabs.css">

    <!-- Diagrams support -->
    <script src="/marathon/js/dagre.min.js"></script>
    <script src="/marathon/js/lodash.min.js"></script>
    <script src="/marathon/js/nomnoml.js"></script>
    <script src="/marathon/js/diagrams.js"></script>

    
    <script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
            (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
            m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-131132823-2', 'auto');
    ga('send', 'pageview');


</script>

    
</head>

<body id="doc-body">
<div id="wrapper">
    <div id="sidebar-wrapper">
    <div>
      <a class="brand" href="/marathon/">
            <img src="/marathon/img/marathon-brand-sidebar.svg" alt="">
      </a>
      <a href="javascript:void(0)" id="main-toggle" class="sidebar-toggle">
            <i class="fa fa-bars"></i>
      </a>
    </div>
    <ul class="sidebar-nav">
    
        
        
        <li class="sidebar-nav-item">
          <a href="#">
            <span>General</span>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul>
            
            
            <li data-order="1">
              <a href="/marathon/doc/getting-started.html">
                  <i class="fa fa-circle"></i>
                  <span>Getting Started</span>
              </a>
            </li>
            
            <li data-order="2">
              <a href="/marathon/doc/downloading.html">
                  <i class="fa fa-circle"></i>
                  <span>Downloading</span>
              </a>
            </li>
            
            <li data-order="3">
              <a href="/marathon/doc/configuration.html">
                  <i class="fa fa-circle"></i>
                  <span>Options</span>
              </a>
            </li>
            
            <li data-order="5">
              <a href="/marathon/doc/executing.html">
                  <i class="fa fa-circle"></i>
                  <span>Executing</span>
              </a>
            </li>
            
            <li data-order="6">
              <a href="/marathon/doc/reports.html">
                  <i class="fa fa-circle"></i>
                  <span>Reporting</span>
              </a>
            </li>
            
            <li data-order="7">
              <a href="/marathon/doc/faq.html">
                  <i class="fa fa-circle"></i>
                  <span>FAQ</span>
              </a>
            </li>
            
            <li data-order="8">
              <a href="/marathon/doc/special-thanks.html">
                  <i class="fa fa-circle"></i>
                  <span>Special thanks</span>
              </a>
            </li>
            
          </ul>
        </li>
    
        
        
        <li class="sidebar-nav-item">
          <a href="#">
            <span>Reference</span>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul>
            
            
            <li data-order="">
              <a href="/marathon/ref/samples.html">
                  <i class="fa fa-circle"></i>
                  <span>Samples</span>
              </a>
            </li>
            
          </ul>
        </li>
    
        
        
        <li class="sidebar-nav-item">
          <a href="#">
            <span>Vendor extensions</span>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul>
            
            
            <li data-order="1">
              <a href="/marathon/ven/android.html">
                  <i class="fa fa-circle"></i>
                  <span>Android</span>
              </a>
            </li>
            
            <li data-order="2">
              <a href="/marathon/ven/ios.html">
                  <i class="fa fa-circle"></i>
                  <span>iOS</span>
              </a>
            </li>
            
          </ul>
        </li>
    
        
        
        <li class="sidebar-nav-item">
          <a href="#">
            <span>Developers</span>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul>
            
            
            <li data-order="2">
              <a href="/marathon/dev/contributing.html">
                  <i class="fa fa-circle"></i>
                  <span>Contributing</span>
              </a>
            </li>
            
            <li data-order="3">
              <a href="/marathon/dev/vision.html">
                  <i class="fa fa-circle"></i>
                  <span>Vision</span>
              </a>
            </li>
            
          </ul>
        </li>
    
    </ul>

</div>

    <div id="doc-wrapper">
    <div class="doc-header">
        <a href="javascript:void(0)" id="main-toggle" class="sidebar-toggle">
            <i class="fa fa-bars"></i>
        </a>
        <div class="search-wrapper">
            <input class="search" id="docsearch" placeholder="Search documentation..." type="search">
        </div>
    </div>
    <div class="doc-content">
        
        <p>Configuration for CLI is done using the YAML formatted configuration file which is placed by default in the root of the project and named as
<strong>Marathonfile</strong>.</p>

<p>Below is an example of Marathonfile (without the vendor module configuration:</p>

<pre><code class="language-yaml">name: "sample-app tests"
outputDir: "./marathon"
analyticsConfiguration:
  type: "influxdb"
  url: "http://influx.svc.cluster.local:8086"
  user: "root"
  password: "root"
  dbName: "marathon"
poolingStrategy:
  type: "omni"
shardingStrategy:
  type: "count"
  count: 5
sortingStrategy:
  type: "success-rate"
  timeLimit: "2015-03-14T09:26:53.590Z"
batchingStrategy:
  type: "fixed-size"
  size: 5
flakinessStrategy:
  type: "probability"
  minSuccessRate: 0.7
  maxCount: 3
  timeLimit: "2015-03-14T09:26:53.590Z"
retryStrategy:
  type: "fixed-quota"
  totalAllowedRetryQuota: 100
  retryPerTestQuota: 3
</code></pre>

<p>Each of these options is covered in detail in the section below. If you’re unsure how to properly format your options in Marathonfile take a
look at the samples or take a look at the <a href="https://github.com/MarathonLabs/marathon/blob/develop/cli/src/main/kotlin/com/malinskiy/marathon/cli/config/ConfigFactory.kt">deserialisation logic</a> in the <em>cli</em> module of the project. Each option might have a default
deserialiser from yaml or a custom one. Usually the custom deserialiser expects the type option to understand which type of strategy we need
to instantiate.</p>

<p>Configuration for gradle plugin is done via gradle only. It doesn’t support the CLI’s marathonfile. Here is an example of gradle config
using Kotlin DSL:</p>

<pre><code class="language-kotlin">marathon {
  name = "sample-app tests"
  baseOutputDir = "./marathon"
  analytics {
    influx {
      url = "http://influx.svc.cluster.local:8086"
      user = "root"
      password = "root"
      dbName = "marathon"
    }
  }
  poolingStrategy {
    operatingSystem = true
  }
  shardingStrategy {
    countSharding {
      count = 5
    }
  }
  sortingStrategy {
    executionTime {
      percentile = 90.0
      executionTime = Instant.now().minus(3, ChronoUnit.DAYS)
    }
  }
  batchingStrategy {
    fixedSize {
      size = 10
    }
  }
  flakinessStrategy {
    probabilityBased {
      minSuccessRate = 0.8
      maxCount = 3
      timeLimit = Instant.now().minus(30, ChronoUnit.DAYS)
    }
  }
  retryStrategy {
    fixedQuota {
      totalAllowedRetryQuota = 200
      retryPerTestQuota = 3
    }
  }
  filteringConfiguration {
    allowlist {
      add(SimpleClassnameFilterConfiguration(".*".toRegex()))
    }
    blocklist {
      add(SimpleClassnameFilterConfiguration("$^".toRegex()))
    }
  }
  testClassRegexes = listOf("^((?!Abstract).)*Test$")
  includeSerialRegexes = emptyList()
  excludeSerialRegexes = emptyList()
  uncompletedTestRetryQuota = 100
  ignoreFailures = false
  isCodeCoverageEnabled = false
  fallbackToScreenshots = false
  testOutputTimeoutMillis = 30_000
  strictMode = false
  debug = true
  autoGrantPermission = true
}
</code></pre>

<p>When specifying <strong>relative host file</strong> paths in the configuration they will be resolved relative to the directory of the Marathonfile, e.g. if
you have <code>/home/user/app/Marathonfile</code> with <code>baseOutputDir = "./output"</code> then the actual path to the output directory will
be <code>/home/user/app/output</code>.</p>

<p>Below you will find a list of currently supported configuration parameters and examples of how to set them up. Keep in mind that some
additional parameters might not be supported by all vendor modules. If you find that something doesn’t work - please submit an issue for a
vendor module at fault.</p>

<ul id="markdown-toc">
  <li><a href="#general-parameters" id="markdown-toc-general-parameters">General parameters</a>    <ul>
      <li><a href="#test-run-configuration-name" id="markdown-toc-test-run-configuration-name">Test run configuration name</a></li>
      <li><a href="#output-directory" id="markdown-toc-output-directory">Output directory</a></li>
    </ul>
  </li>
  <li><a href="#analytics-configuration" id="markdown-toc-analytics-configuration">Analytics configuration</a>    <ul>
      <li><a href="#disabled-analytics" id="markdown-toc-disabled-analytics">Disabled analytics</a></li>
      <li><a href="#influxdb-v2" id="markdown-toc-influxdb-v2">InfluxDB v2</a></li>
      <li><a href="#influxdb" id="markdown-toc-influxdb">InfluxDB</a></li>
      <li><a href="#graphite" id="markdown-toc-graphite">Graphite</a></li>
    </ul>
  </li>
  <li><a href="#execution-flow" id="markdown-toc-execution-flow">Execution flow</a>    <ul>
      <li><a href="#pooling-strategy" id="markdown-toc-pooling-strategy">Pooling strategy</a>        <ul>
          <li><a href="#omni-aka-one-huge-pool" id="markdown-toc-omni-aka-one-huge-pool">Omni a.k.a. one huge pool</a></li>
          <li><a href="#by-abi" id="markdown-toc-by-abi">By abi</a></li>
          <li><a href="#by-manufacturer" id="markdown-toc-by-manufacturer">By manufacturer</a></li>
          <li><a href="#by-device-model" id="markdown-toc-by-device-model">By device model</a></li>
          <li><a href="#by-os-version" id="markdown-toc-by-os-version">By OS version</a></li>
        </ul>
      </li>
      <li><a href="#sharding-strategy" id="markdown-toc-sharding-strategy">Sharding strategy</a>        <ul>
          <li><a href="#parallel-sharding" id="markdown-toc-parallel-sharding">Parallel sharding</a></li>
          <li><a href="#count-sharding" id="markdown-toc-count-sharding">Count sharding</a></li>
        </ul>
      </li>
      <li><a href="#sorting-strategy" id="markdown-toc-sorting-strategy">Sorting strategy</a>        <ul>
          <li><a href="#no-sorting" id="markdown-toc-no-sorting">No sorting</a></li>
          <li><a href="#success-rate-sorting" id="markdown-toc-success-rate-sorting">Success rate sorting</a></li>
          <li><a href="#execution-time-sorting" id="markdown-toc-execution-time-sorting">Execution time sorting</a></li>
        </ul>
      </li>
      <li><a href="#batching-strategy" id="markdown-toc-batching-strategy">Batching strategy</a>        <ul>
          <li><a href="#isolate-batching" id="markdown-toc-isolate-batching">Isolate batching</a></li>
          <li><a href="#fixed-size-batching" id="markdown-toc-fixed-size-batching">Fixed size batching</a></li>
        </ul>
      </li>
      <li><a href="#flakiness-strategy" id="markdown-toc-flakiness-strategy">Flakiness strategy</a>        <ul>
          <li><a href="#ignore-flakiness" id="markdown-toc-ignore-flakiness">Ignore flakiness</a></li>
          <li><a href="#probability-based-flakiness-strategy" id="markdown-toc-probability-based-flakiness-strategy">Probability based flakiness strategy</a></li>
        </ul>
      </li>
      <li><a href="#retry-strategy" id="markdown-toc-retry-strategy">Retry strategy</a>        <ul>
          <li><a href="#no-retries" id="markdown-toc-no-retries">No retries</a></li>
          <li><a href="#fixed-quota-retry-strategy" id="markdown-toc-fixed-quota-retry-strategy">Fixed quota retry strategy</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#additional-parameters" id="markdown-toc-additional-parameters">Additional parameters</a>    <ul>
      <li><a href="#test-filtering-configuration" id="markdown-toc-test-filtering-configuration">Test filtering configuration</a>        <ul>
          <li><a href="#filter-parameters" id="markdown-toc-filter-parameters">Filter parameters</a></li>
          <li><a href="#regex-filtering" id="markdown-toc-regex-filtering">Regex filtering</a></li>
          <li><a href="#values-filtering" id="markdown-toc-values-filtering">Values filtering</a></li>
          <li><a href="#values-file-filtering" id="markdown-toc-values-file-filtering">Values file filtering</a></li>
          <li><a href="#running-only-specific-tests" id="markdown-toc-running-only-specific-tests">Running only specific tests</a></li>
          <li><a href="#more-examples" id="markdown-toc-more-examples">More examples</a></li>
          <li><a href="#composition-filtering" id="markdown-toc-composition-filtering">Composition filtering</a></li>
        </ul>
      </li>
      <li><a href="#fragmented-execution-of-tests" id="markdown-toc-fragmented-execution-of-tests">Fragmented execution of tests</a></li>
      <li><a href="#test-class-regular-expression" id="markdown-toc-test-class-regular-expression">Test class regular expression</a></li>
      <li><a href="#ignore-failures" id="markdown-toc-ignore-failures">Ignore failures</a></li>
      <li><a href="#code-coverage" id="markdown-toc-code-coverage">Code coverage</a></li>
      <li><a href="#test-output-timeout" id="markdown-toc-test-output-timeout">Test output timeout</a></li>
      <li><a href="#test-batch-timeout" id="markdown-toc-test-batch-timeout">Test batch timeout</a></li>
      <li><a href="#device-provider-init-timeout" id="markdown-toc-device-provider-init-timeout">Device provider init timeout</a></li>
      <li><a href="#analytics-tracking" id="markdown-toc-analytics-tracking">Analytics tracking</a></li>
      <li><a href="#uncompleted-test-retry-quota" id="markdown-toc-uncompleted-test-retry-quota">Uncompleted test retry quota</a></li>
      <li><a href="#strict-mode" id="markdown-toc-strict-mode">Strict mode</a></li>
      <li><a href="#debug-mode" id="markdown-toc-debug-mode">Debug mode</a></li>
      <li><a href="#screen-recording-policy" id="markdown-toc-screen-recording-policy">Screen recording policy</a></li>
    </ul>
  </li>
  <li><a href="#vendor-configuration" id="markdown-toc-vendor-configuration">Vendor configuration</a></li>
</ul>

<h1 id="general-parameters">General parameters</h1>

<h2 id="test-run-configuration-name">Test run configuration name</h2>

<p>This string specifies the name of this test run configuration. It is used mainly in the generated test reports.</p>

<ul class="tab" data-tab="cbdee9ce-b803-44bd-89db-221080e5282b">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="cbdee9ce-b803-44bd-89db-221080e5282b">
    
        <li class="active">
<pre><code class="language-yaml">name: "My test run for sample app"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  name = "My test run for sample app"
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  name = "My test run for sample app"
}
</code></pre>

</li>
    
</ul>

<h2 id="output-directory">Output directory</h2>

<p>Directory path to use as the root folder for all the runner output (logs, reports, etc).</p>

<p>For gradle, the output path will automatically be set to a <code>marathon</code> folder in your reports folder unless it’s overridden.</p>

<ul class="tab" data-tab="ac400707-a277-4ea6-9792-7050e38adb4f">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="ac400707-a277-4ea6-9792-7050e38adb4f">
    
        <li class="active">
<pre><code class="language-yaml">outputDir: "build/reports/marathon"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  baseOutputDir = "some-path"
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  baseOutputDir = "some-path"
}
</code></pre>

</li>
    
</ul>

<h1 id="analytics-configuration">Analytics configuration</h1>

<p>Configuration of analytics backend to be used for storing and retrieving test metrics. This plays a major part in optimising performance and
mitigating flakiness.</p>

<h2 id="disabled-analytics">Disabled analytics</h2>

<p>By default no analytics backend is expected which means that each test will be treated as a completely new test.</p>

<h2 id="influxdb-v2"><a href="https://docs.influxdata.com/influxdb/v2.0/">InfluxDB v2</a></h2>

<p>Assuming you’ve done the setup for InfluxDB v2 you need to provide:</p>

<ul>
  <li>url</li>
  <li>token - Token for authentication</li>
  <li>organization - Organization is the name of the organization you wish to write/read from</li>
  <li>bucket - Destination bucket to write/read from</li>
  <li>retention policy</li>
</ul>

<p>Bucket is quite useful in case you have multiple configurations of tests/devices and you don’t want metrics from one configuration to
affect the other one, e.g. regular and end-to-end tests.</p>

<ul class="tab" data-tab="27a1d53e-f8ef-4a1e-8e69-13eb683282ea">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="27a1d53e-f8ef-4a1e-8e69-13eb683282ea">
    
        <li class="active">
<pre><code class="language-yaml">analyticsConfiguration:
  type: "influxdb2"
  url: "http://influx2.svc.cluster.local:8086"
  token: "my-super-secret-token"
  organization: "starlabs"
  bucket: "marathon"
  retentionPolicyConfiguration:
    everySeconds: 604800  # Duration in seconds for how long data will be kept in the database. 0 means infinite. minimum: 0
    shardGroupDurationSeconds: 0 # Shard duration measured in seconds
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  analytics {
    influx {
      url = "http://influx2.svc.cluster.local:8086"
      token = "my-super-secret-token"
      organization = "starlabs"
      bucket = "marathon"
    }
  }
}
</code></pre>

</li>
    
</ul>

<h2 id="influxdb"><a href="https://www.influxdata.com/">InfluxDB</a></h2>

<p>Assuming you’ve done the setup for InfluxDB you need to provide:</p>

<ul>
  <li>url</li>
  <li>username</li>
  <li>password</li>
  <li>database name</li>
  <li>retention policy</li>
</ul>

<p>Database name is quite useful in case you have multiple configurations of tests/devices and you don’t want metrics from one configuration to
affect the other one, e.g. regular and end-to-end tests.</p>

<ul class="tab" data-tab="64ba70bb-afd6-4906-b840-f0c4c14ea9b2">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="64ba70bb-afd6-4906-b840-f0c4c14ea9b2">
    
        <li class="active">
<pre><code class="language-yaml">analyticsConfiguration:
  type: "influxdb"
  url: "http://influx.svc.cluster.local:8086"
  user: "root"
  password: "root"
  dbName: "marathon"
  retentionPolicyConfiguration:
    name: "rpMarathonTest"
    duration: "90d"
    shardDuration: "1h"
    replicationFactor: 5
    isDefault: false
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  analytics {
    influx {
      url = "http://influx.svc.cluster.local:8086"
      user = "root"
      password = "root"
      dbName = "marathon"
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  analytics {
    influx {
      url = "http://influx.svc.cluster.local:8086"
      user = "root"
      password = "root"
      dbName = "marathon"
    }
  }
}
</code></pre>

</li>
    
</ul>

<h2 id="graphite"><a href="https://graphiteapp.org/">Graphite</a></h2>

<p>Graphite can be used as an alternative to InfluxDB. It uses the following parameters:</p>

<ul>
  <li>host</li>
  <li>port (optional) - the default is 2003</li>
  <li>prefix (optional) - no metrics prefix will be used if not specified</li>
</ul>

<ul class="tab" data-tab="57ed6549-51d5-456a-8aa7-c64847e4f9ed">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="57ed6549-51d5-456a-8aa7-c64847e4f9ed">
    
        <li class="active">
<pre><code class="language-yaml">analyticsConfiguration:
  type: "graphite"
  host: "influx.svc.cluster.local"
  port: "8080"
  prefix: "prf"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  analytics {
    graphite {
      host = "influx.svc.cluster.local"
      port = "8080"
      prefix = "prf"
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  analytics {
    graphite {
      host = "influx.svc.cluster.local"
      port = "8080"
      prefix = "prf"
    }
  }
}
</code></pre>

</li>
    
</ul>

<h1 id="execution-flow">Execution flow</h1>

<h2 id="pooling-strategy">Pooling strategy</h2>

<p>Pooling strategy affects how devices are grouped together.</p>

<h3 id="omni-aka-one-huge-pool">Omni a.k.a. one huge pool</h3>

<p>All connected devices are merged into one group. <strong>This is the default mode</strong>.</p>

<ul class="tab" data-tab="e849b917-8b69-4ad6-8ddc-8363d1bcd9ea">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="e849b917-8b69-4ad6-8ddc-8363d1bcd9ea">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  type: "omni"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  //Omni is the default strategy
  poolingStrategy {}
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  //Omni is the default strategy
  poolingStrategy {}
}
</code></pre>

</li>
    
</ul>

<h3 id="by-abi">By abi</h3>

<p>Devices are grouped by their ABI, e.g. <em>x86</em> and <em>mips</em>.</p>

<ul class="tab" data-tab="b9cdefd6-a1da-4795-ab36-11caae8a8a68">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="b9cdefd6-a1da-4795-ab36-11caae8a8a68">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  type: "abi"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  poolingStrategy {
    abi = true
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  poolingStrategy {
    abi = true
  }
}
</code></pre>

</li>
    
</ul>

<h3 id="by-manufacturer">By manufacturer</h3>

<p>Devices are grouped by manufacturer, e.g. <em>Samsung</em> and <em>Yota</em>.</p>

<ul class="tab" data-tab="c847968e-27bd-4853-8651-4fc243f8bbcd">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="c847968e-27bd-4853-8651-4fc243f8bbcd">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  type: "manufacturer"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  poolingStrategy {
    manufacturer = true
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  poolingStrategy {
    manufacturer = true
  }
}
</code></pre>

</li>
    
</ul>

<h3 id="by-device-model">By device model</h3>

<p>Devices are grouped by model name, e.g. <em>LG-D855</em> and <em>SM-N950F</em>.</p>

<ul class="tab" data-tab="7a9405ce-c33f-49a0-b235-96a2685b3ee8">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="7a9405ce-c33f-49a0-b235-96a2685b3ee8">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  type: "device-model"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  poolingStrategy {
    model = true
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  poolingStrategy {
    model = true
  }
}
</code></pre>

</li>
    
</ul>

<h3 id="by-os-version">By OS version</h3>

<p>Devices are grouped by OS version, e.g. <em>24</em> and <em>25</em>.</p>

<ul class="tab" data-tab="9cfa0f3c-77a3-4ba3-b198-98c40d42498a">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="9cfa0f3c-77a3-4ba3-b198-98c40d42498a">
    
        <li class="active">
<pre><code class="language-yaml">poolingStrategy:
  type: "os-version"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  poolingStrategy {
    operatingSystem = true
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  poolingStrategy {
    operatingSystem = true
  }
}
</code></pre>

</li>
    
</ul>

<h2 id="sharding-strategy">Sharding strategy</h2>

<p>Sharding is a mechanism that allows the marathon to affect the tests scheduled for execution inside each pool.</p>

<h3 id="parallel-sharding">Parallel sharding</h3>

<p>Executes each test in parallel on all the available devices in pool. This is the default behaviour.</p>

<ul class="tab" data-tab="0d8aed8a-af84-45b0-b2bc-f9f52f10ff6d">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="0d8aed8a-af84-45b0-b2bc-f9f52f10ff6d">
    
        <li class="active">
<pre><code class="language-yaml">shardingStrategy:
  type: "parallel"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  //Parallel is the default strategy
  shardingStrategy {}
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  //Parallel is the default strategy
  shardingStrategy {}
}
</code></pre>

</li>
    
</ul>

<h3 id="count-sharding">Count sharding</h3>

<p>Executes each test <strong>count</strong> times inside each pool. For example you want to test the flakiness of a specific test hence you need to execute
this test a lot of times. Instead of running the build X times just use this sharding strategy and the test will be executed X times.</p>

<ul class="tab" data-tab="76f90825-45eb-40d2-835e-fc5038e0c760">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="76f90825-45eb-40d2-835e-fc5038e0c760">
    
        <li class="active">
<pre><code class="language-yaml">shardingStrategy:
  type: "count"
  count: 5
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  shardingStrategy {
    countSharding {
      count = 5
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  shardingStrategy {
    countSharding {
      count = 5
    }
  }
}
</code></pre>

</li>
    
</ul>

<h2 id="sorting-strategy">Sorting strategy</h2>

<p>In order to optimise the performance of test execution tests need to be sorted. This requires analytics backend enabled since we need
historical data in order to anticipate tests behaviour like duration and success/failure rate.</p>

<h3 id="no-sorting">No sorting</h3>

<p>No sorting of tests is done at all. This is the default behaviour.</p>

<ul class="tab" data-tab="c4178bb2-d3f6-47fb-929d-428aae03545c">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="c4178bb2-d3f6-47fb-929d-428aae03545c">
    
        <li class="active">
<pre><code class="language-yaml">sortingStrategy:
  type: "no-sorting"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  sortingStrategy {}
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  sortingStrategy {}
}
</code></pre>

</li>
    
</ul>

<h3 id="success-rate-sorting">Success rate sorting</h3>

<p>For each test analytics storage is providing the success rate for a time window specified by time <strong>timeLimit</strong> parameter. All the tests are
then sorted by the success rate in an increasing order, that is failing tests go first and successful tests go last. If you want to reverse
the order set the <code>ascending</code> to <code>true</code>.</p>

<ul class="tab" data-tab="176f7b18-902b-4a26-a05a-3f0202b473ec">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="176f7b18-902b-4a26-a05a-3f0202b473ec">
    
        <li class="active">
<pre><code class="language-yaml">sortingStrategy:
  type: "success-rate"
  timeLimit: "2015-03-14T09:26:53.590Z"
  ascending: false
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  sortingStrategy {
    successRate {
      limit = Instant.now().minus(Duration.parse("PT1H"))
      ascending = false
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  sortingStrategy {
    successRate {
      limit = Instant.now().minus(Duration.parse("PT1H"))
      ascending = false
    }
  }
}
</code></pre>

</li>
    
</ul>

<h3 id="execution-time-sorting">Execution time sorting</h3>

<p>For each test analytics storage is providing the X percentile duration for a time window specified by time <strong>timeLimit</strong> parameter. Apart
from absolute date/time it can be also be an ISO 8601 formatted duration.</p>

<p>Percentile is configurable via the <strong>percentile</strong> parameter.</p>

<p>All the tests are sorted so that long tests go first and short tests are executed last. This allows marathon to minimise the error of
balancing the execution of tests at the end of execution.</p>

<ul class="tab" data-tab="2653671a-71d2-4499-b984-d3073e1ef307">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="2653671a-71d2-4499-b984-d3073e1ef307">
    
        <li class="active">
<pre><code class="language-yaml">sortingStrategy:
  type: "execution-time"
  percentile: 80.0
  timeLimit: "-PT1H"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  sortingStrategy {
    executionTime {
      percentile = 80.0
      timeLimit = Instant.now().minus(Duration.parse("PT1H"))
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  sortingStrategy {
    executionTime {
      percentile = 80.0
      timeLimit = Instant.now().minus(Duration.parse("PT1H"))
    }
  }
}
</code></pre>

</li>
    
</ul>

<h2 id="batching-strategy">Batching strategy</h2>

<p>Batching mechanism allows you to trade off stability for performance. A group of tests executed using one single run is called a batch. Most
of the times this means that between tests in the same batch you’re sharing the device state so there is no clean-up. On the other hand you
gain some performance improvements since the execution command usually is quite slow (up to 10 seconds for some platforms).</p>

<h3 id="isolate-batching">Isolate batching</h3>

<p>No batching is done at all, each test is executed using separate command execution, that is performance is sacrificed in favor of stability.
This is the default mode.</p>

<ul class="tab" data-tab="31bd679b-05cd-43cb-b871-c9a169c61534">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="31bd679b-05cd-43cb-b871-c9a169c61534">
    
        <li class="active">
<pre><code class="language-yaml">batchingStrategy:
  type: "isolate"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  batchingStrategy {}
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  batchingStrategy {}
}
</code></pre>

</li>
    
</ul>

<h3 id="fixed-size-batching">Fixed size batching</h3>

<p>Each batch is created based on the <strong>size</strong> parameter which is required. When a new batch of tests is needed the queue is dequeued for at
most <strong>size</strong> tests.</p>

<p>Optionally if you want to limit the batch duration you have to specify the <strong>timeLimit</strong> for the test metrics time window and the **
durationMillis<strong>. For each test the analytics backend is accessed and **percentile</strong> of it’s duration is queried. If the sum of durations is
more than the <strong>durationMillis</strong> then no more tests are added to the batch.</p>

<p>This is useful if you have very very long tests and you use batching, e.g. you batch by size 10 and your test run duration is roughly 10
minutes, but you have tests that are expected to run 2 minutes each. If you batch all of them together then at least one device will be
finishing it’s execution in 20 minutes while all other devices might already finish. To mitigate this just specify the time limit for the
batch using <strong>durationMillis</strong>.</p>

<p>Another optional parameter for this strategy is the <strong>lastMileLength</strong>. At the end of execution batching tests actually hurts the
performance so for the last tests it’s much better to execute them in parallel in separate batches. This works only if you execute on
multiple devices. You can specify when this optimisation kicks in using the <strong>lastMileLength</strong> parameter, the last <strong>lastMileLength</strong> tests
will use this optimisation.</p>

<ul class="tab" data-tab="e44435ed-69e7-4e11-b08d-e03ea7f58557">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="e44435ed-69e7-4e11-b08d-e03ea7f58557">
    
        <li class="active">
<pre><code class="language-yaml">batchingStrategy:
  type: "fixed-size"
  size: 5
  durationMillis: 100000
  percentile: 80.0
  timeLimit: "-PT1H"
  lastMileLength: 10
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  batchingStrategy {
    fixedSize {
      size = 5
      durationMillis = 100000
      percentile = 80.0
      timeLimit = Instant.now().minus(Duration.parse("PT1H"))
      lastMileLength = 10
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  batchingStrategy {
    fixedSize {
      size = 5
      durationMillis = 100000
      percentile = 80.0
      timeLimit = Instant.now().minus(Duration.parse("PT1H"))
      lastMileLength = 10
    }
  }
}
</code></pre>

</li>
    
</ul>

<h2 id="flakiness-strategy">Flakiness strategy</h2>

<p>This is the main anticipation logic for marathon. Using the analytics backend we can understand the success rate and hence queue preventive
retries to mitigate the flakiness of the tests and environment.</p>

<h3 id="ignore-flakiness">Ignore flakiness</h3>

<p>Nothing is done with this mode. This is the default behaviour.</p>

<ul class="tab" data-tab="15ab432a-3988-4002-893d-89719248286a">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="15ab432a-3988-4002-893d-89719248286a">
    
        <li class="active">
<pre><code class="language-yaml">flakinessStrategy:
  type: "ignore"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  flakinessStrategy {}
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  flakinessStrategy {}
}
</code></pre>

</li>
    
</ul>

<h3 id="probability-based-flakiness-strategy">Probability based flakiness strategy</h3>

<p>The main idea is that flakiness strategy anticipates the flakiness of the test based on the probability of test passing and tries to
maximise the probability of passing when executed multiple times. For example the probability of test A passing is 0.5 and configuration has
probability of 0.8 requested, then the flakiness strategy multiplies the test A to be executed 3 times (0.5 x 0.5 x 0.5 = 0.125 is the
probability of all tests failing, so with probability 0.875 &gt; 0.8 at least one of tests will pass).</p>

<p>The minimal probability that you want is specified using <strong>minSuccessRate</strong> during the time window controlled by the <strong>timeLimit</strong>.
Additionally if you specify too high <strong>minSuccessRate</strong> you’ll have too many retries, so the upper bound for this is controlled by the
<strong>maxCount</strong> parameter so that this strategy will calculate the required number of retries according to the <strong>minSuccessRate</strong> but if it’s
higher than the <strong>maxCount</strong> it will choose <strong>maxCount</strong>.</p>

<ul class="tab" data-tab="3fd0db20-7b87-4190-918f-b14b0e16c53b">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="3fd0db20-7b87-4190-918f-b14b0e16c53b">
    
        <li class="active">
<pre><code class="language-yaml">flakinessStrategy:
  type: "probability"
  minSuccessRate: 0.7
  maxCount: 3
  timeLimit: "2015-03-14T09:26:53.590Z"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  flakinessStrategy {
    probabilityBased {
      minSuccessRate = 0.7
      maxCount = 3
      timeLimit = Instant.now().minus(Duration.parse("PT1H"))
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  flakinessStrategy {
    probabilityBased {
      minSuccessRate = 0.7
      maxCount = 3
      timeLimit = Instant.now().minus(Duration.parse("PT1H"))
    }
  }
}
</code></pre>

</li>
    
</ul>

<h2 id="retry-strategy">Retry strategy</h2>

<p>This is the logic that kicks in if our preventive logic failed to anticipate such high number of retries. This works after the tests were
actually executed.</p>

<h3 id="no-retries">No retries</h3>

<p>As the name implies, no retries are done. This is the default mode.</p>

<ul class="tab" data-tab="61431e65-c3a3-4234-82cd-db780e508b03">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="61431e65-c3a3-4234-82cd-db780e508b03">
    
        <li class="active">
<pre><code class="language-yaml">retryStrategy:
  type: "no-retry"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  retryStrategy {}
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  retryStrategy {}
}
</code></pre>

</li>
    
</ul>

<h3 id="fixed-quota-retry-strategy">Fixed quota retry strategy</h3>

<p>Parameter <strong>totalAllowedRetryQuota</strong> specifies how many retries at all (for all the tests is total) are allowed. <strong>retryPerTestQuota</strong>
controls how many retries can be done for each test individually.</p>

<ul class="tab" data-tab="b41b25dd-a5ca-47f8-a357-6913789a4c98">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="b41b25dd-a5ca-47f8-a357-6913789a4c98">
    
        <li class="active">
<pre><code class="language-yaml">retryStrategy:
  type: "fixed-quota"
  totalAllowedRetryQuota: 100
  retryPerTestQuota: 3
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  retryStrategy {
    fixedQuota {
      retryPerTestQuota = 3
      totalAllowedRetryQuota = 100
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  retryStrategy {
    fixedQuota {
      retryPerTestQuota = 3
      totalAllowedRetryQuota = 100
    }
  }
}
</code></pre>

</li>
    
</ul>

<h1 id="additional-parameters">Additional parameters</h1>

<h2 id="test-filtering-configuration">Test filtering configuration</h2>

<p>In order to indicate to marathon which tests you want to execute you can use the allowlist and blocklist parameters.</p>

<p>First allowlist is applied, then the blocklist. Each accepts a <em>TestFilter</em>:</p>

<table>
  <thead>
    <tr>
      <th>YAML type</th>
      <th style="text-align: center">Gradle class</th>
      <th style="text-align: right">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>“fully-qualified-test-name”</td>
      <td style="text-align: center"><code>FullyQualifiedTestnameFilterConfiguration</code></td>
      <td style="text-align: right">Filters tests by their FQTN which is <code>$package.$class#$method</code>. The <code>#</code> sign is important!</td>
    </tr>
    <tr>
      <td>“fully-qualified-class-name”</td>
      <td style="text-align: center"><code>FullyQualifiedClassnameFilterConfiguration</code></td>
      <td style="text-align: right">Filters tests by their FQCN which is <code>$package.$class</code></td>
    </tr>
    <tr>
      <td>“simple-class-name”</td>
      <td style="text-align: center"><code>SimpleClassnameFilterConfiguration</code></td>
      <td style="text-align: right">Filters tests by using only test class name, e.g. <code>MyTest</code></td>
    </tr>
    <tr>
      <td>“package”</td>
      <td style="text-align: center"><code>TestPackageFilterConfiguration</code></td>
      <td style="text-align: right">Filters tests by using only test package, e.g. <code>com.example</code></td>
    </tr>
    <tr>
      <td>“method”</td>
      <td style="text-align: center"><code>TestMethodFilterConfiguration</code></td>
      <td style="text-align: right">Filters tests by using only test method, e.g. <code>myComplicatedTest</code></td>
    </tr>
    <tr>
      <td>“annotation”</td>
      <td style="text-align: center"><code>AnnotationFilterConfiguration</code></td>
      <td style="text-align: right">Filters tests by using only test annotation name, e.g. <code>androidx.test.filters.LargeTest</code></td>
    </tr>
  </tbody>
</table>

<p>All the filters can be used in allowlist and in blocklist block as well, for example the following will run only smoke tests:</p>

<pre><code class="language-yaml">allowlist:
  - type: "annotation"
    values:
      - "com.example.SmokeTest"
</code></pre>

<p>And the next snippet will execute everything, but the smoke tests:</p>

<pre><code class="language-yaml">blocklist:
  - type: "annotation"
    values:
      - "com.example.SmokeTest"
</code></pre>

<h3 id="filter-parameters">Filter parameters</h3>

<p>Each of the above filters expects <strong>only one</strong> of the following parameters:</p>

<ul>
  <li>A <code>regex</code> for matching</li>
  <li>An array of <code>values</code></li>
  <li>A <code>file</code> that contains each value on a separate line (empty lines will be ignored)</li>
</ul>

<h3 id="regex-filtering">Regex filtering</h3>

<p>An example of <code>regex</code> filtering is executing any test for a particular package, e.g. for package: <code>com.example</code> and it’s subpackages:</p>

<pre><code class="language-yaml">allowlist:
  - type: "package"
    regex: "com\.example.*"
</code></pre>

<h3 id="values-filtering">Values filtering</h3>

<p>You could also specify each package separately via values:</p>

<pre><code class="language-yaml">allowlist:
  - type: "package"
    values:
      - "com.example"
      - "com.example.subpackage"
</code></pre>

<h3 id="values-file-filtering">Values file filtering</h3>

<p>Or you can supply these packages via a file (be careful with the relative paths: they will be relative to the workdir of the process):</p>

<pre><code class="language-yaml">allowlist:
  - type: "package"
    file: "testing/myfilterfile"
</code></pre>

<p>Inside the <code>testing/myfilterfile</code> you should supply the values, each on a separate line:</p>

<pre><code>com.example
com.example.subpackage
</code></pre>

<h3 id="running-only-specific-tests">Running only specific tests</h3>

<p>A common scenario is to execute a list of tests. You can do this via the FQTN filter:</p>

<ul class="tab" data-tab="cfe3e340-53b6-4930-a387-1d81545dec31">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="cfe3e340-53b6-4930-a387-1d81545dec31">
    
        <li class="active">
<pre><code class="language-yaml">allowlist:
  - type: "fully-qualified-test-name"
    values:
      - "com.example.ElaborateTest#testMethod"
      - "com.example.subpackage.OtherTest#testSomethingElse"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  filteringConfiguration {
    allowlist {
      add(
        FullyQualifiedTestnameFilterConfiguration(
          values = listOf(
            "com.example.ElaborateTest#testMethod",
            "com.example.subpackage.OtherTest#testSomethingElse",
          )
        )
      )
    }
  }
}
</code></pre>

</li>
    
</ul>

<h3 id="more-examples">More examples</h3>

<p>If you want to execute tests <code>ScaryTest</code> and <code>FlakyTest</code> for any package using the <em>class name</em> filter:</p>

<pre><code class="language-yaml">- type: "simple-class-name"
  values:
    - "ScaryTest"
    - "FlakyTest" 
</code></pre>

<p>In case you want to separate the filtering configuration from the <em>Marathonfile</em> you can supply a reference to an external file:</p>

<pre><code class="language-yaml">- type: "simple-class-name"
  file: testing/myfilterfile
</code></pre>

<p>Inside the <code>testing/myfilterfile</code> you should supply the same values, each on a separate line, e.g. <em>fully qualified class name</em> filter:</p>

<pre><code>com.example.ScaryTest
com.example.subpackage.FlakyTest
</code></pre>

<h3 id="composition-filtering">Composition filtering</h3>

<p>In order to filter using multiple filters at the same time a <em>composition</em> filter is also available which accepts a list of base filters and
also an operation such as <strong>UNION</strong>, <strong>INTERSECTION</strong> or <strong>SUBTRACT</strong>. You can create complex filters such as get all the tests starting
with <em>E2E</em> but get only methods from there ending with <em>Test</em>. Composition filter is not supported by groovy gradle scripts, but is
supported if you use gradle kts.</p>

<p>An important thing to mention is that by default platform specific ignore options are not taken into account. This is because a
cross-platform test runner cannot account for all the possible test frameworks out there. However, each framework’s ignore option can still
be “explained” to marathon, e.g. JUnit’s <strong>org.junit.Ignore</strong> annotation can be specified in the filtering configuration.</p>

<ul class="tab" data-tab="10788a54-5130-4647-8f57-25962c9e0776">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="10788a54-5130-4647-8f57-25962c9e0776">
    
        <li class="active">
<pre><code class="language-yaml">filteringConfiguration:
  allowlist:
    - type: "simple-class-name"
      regex: ".*"
    - type: "fully-qualified-class-name"
      values:
        - "com.example.MyTest"
        - "com.example.MyOtherTest"
    - type: "fully-qualified-class-name"
      file: "testing/mytestfilter"
    - type: "method"
      regex: "."
    - type: "composition"
      filters:
        - type: "package"
          regex: ".*"
        - type: "method"
          regex: ".*"
      op: "UNION"
  blocklist:
    - type: "package"
      regex: ".*"
    - type: "annotation"
      regex: ".*"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">//Simple access Groovy configuration doesn't allow specifying anything besides the test filter regex
marathon {
  filteringConfiguration {
    allowlist {
      simpleClassNameFilter = [".*"]
      fullyQualifiedClassnameFilter = [".*"]
      testMethodFilter = [".*"]
    }
    blocklist {
      testPackageFilter = [".*"]
      annotationFilter = [".*"]
    }
  }
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  filteringConfiguration {
    allowlist = mutableListOf(
      SimpleClassnameFilterConfiguration(".*".toRegex()),
      FullyQualifiedClassnameFilterConfiguration(".*".toRegex()),
      TestMethodFilterConfiguration(".*".toRegex()),
      CompositionFilterConfiguration(
        listOf(
          TestPackageFilterConfiguration(".*".toRegex()),
          TestMethodFilterConfiguration(".*".toRegex())
        ),
        CompositionFilterConfiguration.OPERATION.UNION
      )
    )
    blocklist = mutableListOf(
      TestPackageFilterConfiguration(".*".toRegex()),
      AnnotationFilterConfiguration(".*".toRegex())
    )
  }
}
</code></pre>

</li>
    
</ul>

<h2 id="fragmented-execution-of-tests">Fragmented execution of tests</h2>

<p>This is a test filter similar to sharded test execution that <a href="https://source.android.com/devices/tech/test_infra/tradefed/architecture/advanced/sharding">AOSP provides</a>.</p>

<p>It is intended to be used in situations where it is not possible to connect multiple execution devices to a single test run, e.g. CI setup
that can schedule parallel jobs each containing a single execution device. There are two parameters for using fragmentation:</p>

<ul>
  <li><strong>count</strong> - the number of overall fragments (e.g. 10 parallel execution)</li>
  <li><strong>index</strong> - current execution index (in our case of 10 executions valid indexes are 0..9)</li>
</ul>

<p>This is a dynamic programming technique, hence the results will be sub-optimal compared to connecting multiple devices to the same test run</p>

<ul class="tab" data-tab="cd5681c1-097f-4527-8e80-d39fba1db129">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="cd5681c1-097f-4527-8e80-d39fba1db129">
    
        <li class="active">
<pre><code class="language-yaml">filteringConfiguration:
  allowlist:
    - type: "fragmentation"
      index: 0
      count: 10
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  filteringConfiguration {
    allowlist = mutableListOf(
      FragmentationFilterConfiguration(index = 0, count = 10)
    )
  }
}
</code></pre>

</li>
    
</ul>

<p>If you want to dynamically pass the index of the test run you can use yaml envvar interpolation, e.g.:</p>

<pre><code class="language-yaml">filteringConfiguration:
  allowlist:
    - type: "fragmentation"
      index: ${MARATHON_FRAGMENT_INDEX}
      count: 10
</code></pre>

<p>and then execute the testing as following:</p>

<pre><code class="language-bash">$ MARATHON_FRAGMENT_INDEX=0 marathon
</code></pre>

<p>To pass the fragment index in gradle refer to
the <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#properties">Gradle’s dynamic project properties</a></p>

<h2 id="test-class-regular-expression">Test class regular expression</h2>

<p>By default, test classes are found using the <code>"^((?!Abstract).)*Test[s]*$"</code> regex. You can override this if you need to.</p>

<ul class="tab" data-tab="f5b1a3d7-f7d4-4e25-be1b-74fdbd1475f1">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="f5b1a3d7-f7d4-4e25-be1b-74fdbd1475f1">
    
        <li class="active">
<pre><code class="language-yaml">testClassRegexes:
  - "^((?!Abstract).)*Test[s]*$"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  testClassRegexes = [
    "^((?!Abstract).)*Test[s]*\$"
  ]
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  testClassRegexes = listOf(
    "^((?!Abstract).)*Test[s]*$"
  )
}
</code></pre>

</li>
    
</ul>

<h2 id="ignore-failures">Ignore failures</h2>

<p>By default, the build fails if some tests failed. If you want to the build to succeed even if some tests failed use <em>true</em>.</p>

<ul class="tab" data-tab="b3c7eb3c-0912-464f-a33f-832fd2efb96a">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="b3c7eb3c-0912-464f-a33f-832fd2efb96a">
    
        <li class="active">
<pre><code class="language-yaml">ignoreFailures: true
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  ignoreFailures = true
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  ignoreFailures = true
}
</code></pre>

</li>
    
</ul>

<h2 id="code-coverage">Code coverage</h2>

<p>Depending on the vendor implementation code coverage may not be supported. By default, code coverage is disabled. If this option is enabled,
code coverage will be collected and marathon assumes that code coverage generation will be setup by user (e.g. proper build flags, jacoco
jar added to classpath, etc).</p>

<ul class="tab" data-tab="01e51353-4ce0-477a-9a99-31687f750081">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="01e51353-4ce0-477a-9a99-31687f750081">
    
        <li class="active">
<pre><code class="language-yaml">isCodeCoverageEnabled: true
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  codeCoverageEnabled = true
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  isCodeCoverageEnabled = true
}
</code></pre>

</li>
    
</ul>

<h2 id="test-output-timeout">Test output timeout</h2>

<p>This parameter specifies the behaviour for the underlying test executor to timeout if there is no output. By default, this is set to 5
minutes.</p>

<ul class="tab" data-tab="1db2673d-a530-4520-9fdb-6e80e65ee634">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="1db2673d-a530-4520-9fdb-6e80e65ee634">
    
        <li class="active">
<pre><code class="language-yaml">testOutputTimeoutMillis: 30000
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  testOutputTimeoutMillis = 30000
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  testOutputTimeoutMillis = 30000
}
</code></pre>

</li>
    
</ul>

<h2 id="test-batch-timeout">Test batch timeout</h2>

<p>This parameter specifies the behaviour for the underlying test executor to timeout if the batch execution exceeded some duration. By
default, this is set to 30 minutes.</p>

<ul class="tab" data-tab="027bf529-dc25-4a23-beb5-35177b48a857">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="027bf529-dc25-4a23-beb5-35177b48a857">
    
        <li class="active">
<pre><code class="language-yaml">testBatchTimeoutMillis: 900000
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  testBatchTimeoutMillis = 900000
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  testBatchTimeoutMillis = 900000
}
</code></pre>

</li>
    
</ul>

<h2 id="device-provider-init-timeout">Device provider init timeout</h2>

<p>When the test run starts device provider is expected to provide some devices. This should not take more than 3 minutes by default. If your
setup requires this to be changed please override as following:</p>

<ul class="tab" data-tab="ae5dee09-030e-45de-8b05-cc4430a13695">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="ae5dee09-030e-45de-8b05-cc4430a13695">
    
        <li class="active">
<pre><code class="language-yaml">deviceInitializationTimeoutMillis: 300000
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  deviceInitializationTimeoutMillis = 300000
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  deviceInitializationTimeoutMillis = 300000
}
</code></pre>

</li>
    
</ul>

<h2 id="analytics-tracking">Analytics tracking</h2>

<p>To better understand the use-cases that marathon is used for we’re asking you to provide us with anonymised information about your usage. By
default, this is disabled. Use <strong>true</strong> to enable.</p>

<ul class="tab" data-tab="d84533aa-ec35-4c09-bf8a-7cb63d947910">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="d84533aa-ec35-4c09-bf8a-7cb63d947910">
    
        <li class="active">
<pre><code class="language-yaml">analyticsTracking: true
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  analyticsTracking = true
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  analyticsTracking = true
}
</code></pre>

</li>
    
</ul>

<h2 id="uncompleted-test-retry-quota">Uncompleted test retry quota</h2>

<p>By default, tests that don’t have any status reported after execution (for example a device disconnected during the execution) retry
indefinitely. You can limit the number of total execution for such cases using this option.</p>

<ul class="tab" data-tab="56f1efc0-8f3f-415f-ad7c-7ad411dc4c33">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="56f1efc0-8f3f-415f-ad7c-7ad411dc4c33">
    
        <li class="active">
<pre><code class="language-yaml">uncompletedTestRetryQuota: 100
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  uncompletedTestRetryQuota = 100
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  uncompletedTestRetryQuota = 100
}
</code></pre>

</li>
    
</ul>

<h2 id="strict-mode">Strict mode</h2>

<p>By default, if one of the test retries succeeds then the test is considered successfully executed. If you require success status only when
all retries were executed successfully you can enable the strict mode. This may be useful to verify that flakiness of tests was fixed for
example.</p>

<ul class="tab" data-tab="81fb5145-3890-4e0e-82bc-a096e8ace89f">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="81fb5145-3890-4e0e-82bc-a096e8ace89f">
    
        <li class="active">
<pre><code class="language-yaml">strictMode: true
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  strictMode = true
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  strictMode = true
}
</code></pre>

</li>
    
</ul>

<h2 id="debug-mode">Debug mode</h2>

<p>Enabled very verbose logging to stdout of all the marathon components. Very useful for debugging.</p>

<ul class="tab" data-tab="3c0c0adb-d266-42ac-9505-fb337f7ca49d">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="3c0c0adb-d266-42ac-9505-fb337f7ca49d">
    
        <li class="active">
<pre><code class="language-yaml">debug: true
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  debug = true
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  debug = true
}
</code></pre>

</li>
    
</ul>

<h2 id="screen-recording-policy">Screen recording policy</h2>

<p>By default, screen recording will only be pulled for tests that failed (<strong>ON_FAILURE</strong> option). This is to save space and also to reduce the
test duration time since we’re not pulling additional files. If you need to save screen recording regardless of the test pass/failure please
use the <strong>ON_ANY</strong> option:</p>

<ul class="tab" data-tab="42e583b7-6260-46c5-aa6a-d4b5591a2692">
    
        <li class="active">
            <a href="">Marathonfile </a>
        </li>
    
        <li>
            <a href="">Gradle </a>
        </li>
    
        <li>
            <a href="">Gradle Kotlin </a>
        </li>
    
</ul>
<ul class="tab-content" id="42e583b7-6260-46c5-aa6a-d4b5591a2692">
    
        <li class="active">
<pre><code class="language-yaml">screenRecordingPolicy: "ON_ANY"
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  screenRecordingPolicy = ScreenRecordingPolicy.ON_ANY
}
</code></pre>

</li>
    
        <li>
<pre><code class="language-kotlin">marathon {
  screenRecordingPolicy = ScreenRecordingPolicy.ON_ANY
}
</code></pre>

</li>
    
</ul>

<h1 id="vendor-configuration">Vendor configuration</h1>

<p>See relevant vendor module page, e.g. <a href="/marathon/ven/android.html">Android</a> or <a href="/marathon/ven/ios.html">iOS</a></p>


    </div>
</div>

</div>
<!-- Jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js"></script>
<script> hljs.initHighlighting(); </script>
<!-- Docsearch -->
<script src="/marathon/js/docsearch.min.js" type="text/javascript"></script>
<!-- Touch gesture support -->
<script src="/marathon/js/hammer.min.js"></script>
<!-- Custom scripts for this template -->
<script src="/marathon/js/functions.js"></script>
<script src="/marathon/js/tabs.js"></script>

</body>
</html>
